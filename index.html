<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ツインスティックシューティング (改善版)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow: hidden;
        }
        canvas {
            background-color: #0a0a0a;
            display: block;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.7);
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        .game-text {
            color: #fff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            text-align: center;
        }
        #score-container {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 2em;
        }
        #highscore-container {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.5em;
            text-align: right;
            color: rgba(255, 255, 255, 0.8);
        }
        #lives-container {
            position: absolute;
            top: 65px;
            left: 20px;
            display: flex;
        }
        .life-icon {
             width: 20px;
             height: 20px;
             background-color: white;
             margin-right: 10px;
             border-radius: 50%;
             box-shadow: 0 0 10px white;
        }
        #gamepad-status {
            position: absolute;
            bottom: 20px;
            width: 100%;
            font-size: 1em;
            color: rgba(255, 255, 255, 0.5);
        }
        .overlay {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: all;
        }
        .overlay h1 { font-size: 5em; margin: 0; }
        .overlay p { font-size: 2em; margin: 10px 0; }
        .overlay .prompt { font-size: 1.2em; margin-top: 40px; color: #0ff; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-container">
        <div id="score-container" class="game-text">SCORE: 0</div>
        <div id="highscore-container" class="game-text">HI-SCORE: 0</div>
        <div id="lives-container"></div>
        <div id="gamepad-status" class="game-text">キーボードで操作: WASDで移動, 矢印キーでショット<br>ゲームパッドを接続してください</div>
    </div>
    
    <div id="start-screen" class="overlay">
        <h1 class="game-text">GEOMETRY WARS</h1>
        <p class="prompt">Press ENTER or Gamepad Button to START</p>
    </div>

    <div id="game-over-screen" class="overlay hidden">
        <h1 class="game-text">GAME OVER</h1>
        <p id="final-score" class="game-text">YOUR SCORE: 0</p>
        <p class="prompt">Press ENTER or Gamepad Button to RESTART</p>
    </div>

    <script>
        // 定数定義
        const GAME_CONSTANTS = {
            PLAYER: {
                RADIUS: 15,
                SPEED: 5,
                SHOOT_COOLDOWN: 5,
                INVINCIBILITY_FRAMES: 180,
                COLOR: 'white'
            },
            PROJECTILE: {
                RADIUS: 5,
                SPEED: 7,
                COLOR: 'cyan'
            },
            ENEMY: {
                MIN_RADIUS: 10,
                MAX_RADIUS: 30,
                BASE_SPEED: 2,
                WANDERER_SPEED_MULTIPLIER: 0.5,
                WANDERER_SPAWN_CHANCE: 0.2,
                COLORS: ['#ff00ff', '#ff9900', '#ffff00', '#00ff00']
            },
            PARTICLE: {
                PLAYER_DEATH_COUNT: 80,
                PLAYER_DEATH_SPEED: 10,
                PLAYER_DEATH_SIZE: 4,
                PLAYER_DEATH_LIFE: 60,
                ENEMY_DEATH_MULTIPLIER: 1.5,
                ENEMY_DEATH_SPEED: 5,
                ENEMY_DEATH_SIZE_MIN: 1,
                ENEMY_DEATH_SIZE_RANGE: 1,
                ENEMY_DEATH_LIFE: 30
            },
            GAME: {
                INITIAL_LIVES: 3,
                INITIAL_SPAWN_TIMER: 100,
                MIN_SPAWN_TIMER: 20,
                SPAWN_TIMER_SCORE_DIVISOR: 100,
                SCORE_PER_KILL: 100,
                SCREEN_SHAKE_DURATION: 20,
                SCREEN_SHAKE_MAGNITUDE: 15,
                GRID_SIZE: 50,
                GAMEPAD_DEADZONE: 0.25
            },
            STORAGE_KEY: 'twinStickHighScore'
        };

        // ゲーム状態管理クラス
        class GameState {
            constructor() {
                this.state = 'START'; // START, PLAYING, GAMEOVER
                this.score = 0;
                this.highScore = 0;
                this.lives = GAME_CONSTANTS.GAME.INITIAL_LIVES;
                this.screenShake = { duration: 0, magnitude: 0 };
            }

            reset() {
                this.state = 'PLAYING';
                this.score = 0;
                this.lives = GAME_CONSTANTS.GAME.INITIAL_LIVES;
                this.screenShake = { duration: 0, magnitude: 0 };
            }

            addScore(points) {
                this.score += points;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.saveHighScore();
                }
            }

            loseLife() {
                this.lives--;
                return this.lives > 0;
            }

            loadHighScore() {
                try {
                    const saved = localStorage.getItem(GAME_CONSTANTS.STORAGE_KEY);
                    this.highScore = saved ? parseInt(saved, 10) : 0;
                } catch (error) {
                    console.error('Failed to load high score:', error);
                    this.highScore = 0;
                }
            }

            saveHighScore() {
                try {
                    localStorage.setItem(GAME_CONSTANTS.STORAGE_KEY, this.highScore.toString());
                } catch (error) {
                    console.error('Failed to save high score:', error);
                }
            }

            triggerScreenShake() {
                this.screenShake = {
                    duration: GAME_CONSTANTS.GAME.SCREEN_SHAKE_DURATION,
                    magnitude: GAME_CONSTANTS.GAME.SCREEN_SHAKE_MAGNITUDE
                };
            }

            updateScreenShake() {
                if (this.screenShake.duration > 0) {
                    this.screenShake.duration--;
                    return {
                        x: (Math.random() - 0.5) * this.screenShake.magnitude,
                        y: (Math.random() - 0.5) * this.screenShake.magnitude
                    };
                }
                return { x: 0, y: 0 };
            }
        }

        // 入力管理クラス
        class InputManager {
            constructor() {
                this.keys = {
                    w: false, a: false, s: false, d: false,
                    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
                    Enter: false
                };
                this.gamepad = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) this.keys[e.key] = true;
                });
                window.addEventListener('keyup', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) this.keys[e.key] = false;
                });
                window.addEventListener("gamepadconnected", (e) => {
                    this.gamepad = e.gamepad;
                    this.onGamepadConnected(e.gamepad);
                });
                window.addEventListener("gamepaddisconnected", () => {
                    this.gamepad = null;
                    this.onGamepadDisconnected();
                });
            }

            onGamepadConnected(gamepad) {
                const statusEl = document.getElementById('gamepad-status');
                statusEl.textContent = `ゲームパッド接続中: ${gamepad.id}`;
                statusEl.style.color = '#0ff';
            }

            onGamepadDisconnected() {
                const statusEl = document.getElementById('gamepad-status');
                statusEl.innerHTML = `キーボードで操作: WASDで移動, 矢印キーでショット<br>ゲームパッドを接続してください`;
                statusEl.style.color = 'rgba(255,255,255,0.5)';
            }

            getMovement() {
                let moveX = 0, moveY = 0;
                const deadzone = GAME_CONSTANTS.GAME.GAMEPAD_DEADZONE;
                
                if (this.gamepad) {
                    const gp = navigator.getGamepads()[this.gamepad.index];
                    if (gp) {
                        const leftStickX = gp.axes[0];
                        const leftStickY = gp.axes[1];
                        if (Math.abs(leftStickX) > deadzone) moveX = leftStickX;
                        if (Math.abs(leftStickY) > deadzone) moveY = leftStickY;
                    }
                }
                
                if (moveX === 0 && moveY === 0) {
                    if (this.keys.w) moveY -= 1;
                    if (this.keys.s) moveY += 1;
                    if (this.keys.a) moveX -= 1;
                    if (this.keys.d) moveX += 1;
                }
                
                return { x: moveX, y: moveY };
            }

            getShooting() {
                let shootX = 0, shootY = 0;
                const deadzone = GAME_CONSTANTS.GAME.GAMEPAD_DEADZONE;
                
                if (this.gamepad) {
                    const gp = navigator.getGamepads()[this.gamepad.index];
                    if (gp) {
                        const rightStickX = gp.axes[2];
                        const rightStickY = gp.axes[3];
                        if (Math.abs(rightStickX) > deadzone) shootX = rightStickX;
                        if (Math.abs(rightStickY) > deadzone) shootY = rightStickY;
                    }
                }
                
                if (shootX === 0 && shootY === 0) {
                    if (this.keys.ArrowUp) shootY -= 1;
                    if (this.keys.ArrowDown) shootY += 1;
                    if (this.keys.ArrowLeft) shootX -= 1;
                    if (this.keys.ArrowRight) shootX += 1;
                }
                
                return { x: shootX, y: shootY };
            }

            isStartPressed() {
                let pressed = this.keys.Enter;
                if (this.gamepad) {
                    const gp = navigator.getGamepads()[this.gamepad.index];
                    if (gp && (gp.buttons[9].pressed || gp.buttons[0].pressed)) {
                        pressed = true;
                    }
                }
                return pressed;
            }
        }

        // ベクトルユーティリティ
        class Vector {
            constructor(x, y) { 
                this.x = x; 
                this.y = y; 
            }
            
            get magnitude() { 
                return Math.sqrt(this.x * this.x + this.y * this.y); 
            }
            
            normalize() {
                const mag = this.magnitude;
                if (mag > 0) { 
                    this.x /= mag; 
                    this.y /= mag; 
                }
                return this;
            }
        }

        // エンティティクラス
        class Particle {
            constructor(x, y, color, velocity, size, life) {
                this.x = x; 
                this.y = y; 
                this.color = color; 
                this.velocity = velocity;
                this.size = size; 
                this.life = life; 
                this.initialLife = life;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life / this.initialLife;
                ctx.fillStyle = this.color; 
                ctx.shadowColor = this.color; 
                ctx.shadowBlur = 10;
                ctx.beginPath(); 
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore();
            }
            
            update() { 
                this.x += this.velocity.x; 
                this.y += this.velocity.y; 
                this.life--; 
            }
            
            isAlive() {
                return this.life > 0;
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x; 
                this.y = y; 
                this.radius = GAME_CONSTANTS.PLAYER.RADIUS; 
                this.color = GAME_CONSTANTS.PLAYER.COLOR;
                this.speed = GAME_CONSTANTS.PLAYER.SPEED; 
                this.shootCooldown = 0;
                this.isInvincible = false; 
                this.invincibilityTimer = 0;
            }
            
            draw(ctx) {
                ctx.save();
                if (this.isInvincible) {
                    ctx.globalAlpha = this.invincibilityTimer % 20 < 10 ? 0.5 : 1;
                }
                ctx.fillStyle = this.color; 
                ctx.shadowColor = this.color; 
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            update(inputManager, canvas) {
                if (this.invincibilityTimer > 0) {
                    this.invincibilityTimer--;
                } else {
                    this.isInvincible = false;
                }

                const movement = inputManager.getMovement();
                const moveVec = new Vector(movement.x, movement.y);
                
                if (moveVec.magnitude > 0) {
                    const moveSpeed = this.speed * Math.min(1, moveVec.magnitude);
                    moveVec.normalize();
                    this.x += moveVec.x * moveSpeed; 
                    this.y += moveVec.y * moveSpeed;
                }
                
                this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

                if (this.shootCooldown > 0) this.shootCooldown--;
            }
            
            tryShoot(inputManager) {
                if (this.shootCooldown > 0) return null;
                
                const shooting = inputManager.getShooting();
                const shootVec = new Vector(shooting.x, shooting.y);
                
                if (shootVec.magnitude > 0) {
                    shootVec.normalize();
                    this.shootCooldown = GAME_CONSTANTS.PLAYER.SHOOT_COOLDOWN;
                    return new Projectile(
                        this.x, 
                        this.y, 
                        { x: shootVec.x * GAME_CONSTANTS.PROJECTILE.SPEED, 
                          y: shootVec.y * GAME_CONSTANTS.PROJECTILE.SPEED }
                    );
                }
                return null;
            }
            
            makeInvincible() {
                this.isInvincible = true;
                this.invincibilityTimer = GAME_CONSTANTS.PLAYER.INVINCIBILITY_FRAMES;
            }
            
            respawn(canvas) {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.makeInvincible();
            }
        }

        class Projectile {
            constructor(x, y, velocity) {
                this.x = x; 
                this.y = y; 
                this.radius = GAME_CONSTANTS.PROJECTILE.RADIUS; 
                this.color = GAME_CONSTANTS.PROJECTILE.COLOR; 
                this.velocity = velocity;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.fillStyle = this.color; 
                ctx.shadowColor = this.color; 
                ctx.shadowBlur = 15;
                ctx.beginPath(); 
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore();
            }
            
            update() { 
                this.x += this.velocity.x; 
                this.y += this.velocity.y; 
            }
            
            isOutOfBounds(canvas) {
                return this.x < 0 || this.x > canvas.width || 
                       this.y < 0 || this.y > canvas.height;
            }
        }

        class Enemy {
            constructor(x, y, radius, color, velocity, type = 'seeker') {
                this.x = x; 
                this.y = y; 
                this.radius = radius; 
                this.color = color; 
                this.velocity = velocity;
                this.type = type;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.strokeStyle = this.color; 
                ctx.shadowColor = this.color; 
                ctx.shadowBlur = 20; 
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.radius); 
                ctx.lineTo(this.x + this.radius, this.y);
                ctx.lineTo(this.x, this.y + this.radius); 
                ctx.lineTo(this.x - this.radius, this.y);
                ctx.closePath(); 
                ctx.stroke();
                ctx.restore();
            }
            
            update(player) {
                if(this.type === 'seeker') {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.velocity.x = Math.cos(angle); 
                    this.velocity.y = Math.sin(angle);
                }
                this.x += this.velocity.x * GAME_CONSTANTS.ENEMY.BASE_SPEED; 
                this.y += this.velocity.y * GAME_CONSTANTS.ENEMY.BASE_SPEED;
            }
            
            checkCollision(other) {
                const dist = Math.hypot(this.x - other.x, this.y - other.y);
                return dist < this.radius + other.radius;
            }
        }

        // エンティティマネージャー
        class EntityManager {
            constructor() {
                this.projectiles = [];
                this.enemies = [];
                this.particles = [];
            }

            reset() {
                this.projectiles = [];
                this.enemies = [];
                this.particles = [];
            }

            addProjectile(projectile) {
                if (projectile) this.projectiles.push(projectile);
            }

            addEnemy(enemy) {
                this.enemies.push(enemy);
            }

            addParticle(particle) {
                this.particles.push(particle);
            }

            createExplosion(x, y, color, config) {
                for (let i = 0; i < config.count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * config.speed;
                    this.addParticle(new Particle(
                        x, y, color,
                        { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed },
                        Math.random() * config.sizeRange + config.sizeMin,
                        config.life
                    ));
                }
            }

            update(player, canvas) {
                // パーティクル更新
                this.particles = this.particles.filter(particle => {
                    particle.update();
                    return particle.isAlive();
                });

                // 弾丸更新
                this.projectiles = this.projectiles.filter(projectile => {
                    projectile.update();
                    return !projectile.isOutOfBounds(canvas);
                });

                // 敵更新
                this.enemies.forEach(enemy => enemy.update(player));
            }

            checkCollisions(player, gameState) {
                const collisions = { playerHit: false, enemiesKilled: [] };

                // プレイヤーと敵の衝突
                if (!player.isInvincible) {
                    this.enemies.forEach((enemy, index) => {
                        if (enemy.checkCollision(player)) {
                            collisions.playerHit = true;
                        }
                    });
                }

                // 弾丸と敵の衝突
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        if (this.enemies[j].checkCollision(this.projectiles[i])) {
                            collisions.enemiesKilled.push({
                                enemy: this.enemies[j],
                                projectile: this.projectiles[i]
                            });
                            this.enemies.splice(j, 1);
                            this.projectiles.splice(i, 1);
                            break;
                        }
                    }
                }

                return collisions;
            }

            clearAllEnemies() {
                this.enemies.forEach(enemy => {
                    this.createExplosion(enemy.x, enemy.y, enemy.color, {
                        count: enemy.radius * GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_MULTIPLIER,
                        speed: GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_SPEED,
                        sizeMin: GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_SIZE_MIN,
                        sizeRange: GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_SIZE_RANGE,
                        life: GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_LIFE
                    });
                });
                this.enemies = [];
            }

            draw(ctx) {
                this.particles.forEach(p => p.draw(ctx));
                this.projectiles.forEach(p => p.draw(ctx));
                this.enemies.forEach(e => e.draw(ctx));
            }
        }

        // ゲームクラス
        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.gameState = new GameState();
                this.inputManager = new InputManager();
                this.entityManager = new EntityManager();
                this.player = null;
                this.enemySpawnTimer = 0;
                this.animationFrameId = null;
                
                this.setupUI();
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            setupUI() {
                this.ui = {
                    score: document.getElementById('score-container'),
                    highScore: document.getElementById('highscore-container'),
                    lives: document.getElementById('lives-container'),
                    startScreen: document.getElementById('start-screen'),
                    gameOverScreen: document.getElementById('game-over-screen'),
                    finalScore: document.getElementById('final-score')
                };
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            init() {
                this.gameState.loadHighScore();
                this.updateUI();
                this.ui.startScreen.classList.remove('hidden');
                this.ui.gameOverScreen.classList.add('hidden');
                this.gameLoop();
            }

            start() {
                this.gameState.reset();
                this.entityManager.reset();
                this.player = new Player(this.canvas.width / 2, this.canvas.height / 2);
                this.enemySpawnTimer = GAME_CONSTANTS.GAME.INITIAL_SPAWN_TIMER;
                
                this.ui.startScreen.classList.add('hidden');
                this.ui.gameOverScreen.classList.add('hidden');
                this.updateUI();
            }

            updateUI() {
                this.ui.score.textContent = `SCORE: ${this.gameState.score}`;
                this.ui.highScore.textContent = `HI-SCORE: ${this.gameState.highScore}`;
                
                this.ui.lives.innerHTML = '';
                for (let i = 0; i < this.gameState.lives; i++) {
                    const lifeIcon = document.createElement('div');
                    lifeIcon.className = 'life-icon';
                    this.ui.lives.appendChild(lifeIcon);
                }
            }

            handlePlayerDeath() {
                // 爆発エフェクト
                this.entityManager.createExplosion(
                    this.player.x, this.player.y, 
                    GAME_CONSTANTS.PLAYER.COLOR,
                    {
                        count: GAME_CONSTANTS.PARTICLE.PLAYER_DEATH_COUNT,
                        speed: GAME_CONSTANTS.PARTICLE.PLAYER_DEATH_SPEED,
                        sizeMin: 1,
                        sizeRange: GAME_CONSTANTS.PARTICLE.PLAYER_DEATH_SIZE - 1,
                        life: GAME_CONSTANTS.PARTICLE.PLAYER_DEATH_LIFE
                    }
                );

                this.gameState.triggerScreenShake();
                this.entityManager.clearAllEnemies();

                if (this.gameState.loseLife()) {
                    this.player.respawn(this.canvas);
                    this.updateUI();
                } else {
                    this.gameOver();
                }
            }

            gameOver() {
                this.gameState.state = 'GAMEOVER';
                this.gameState.saveHighScore();
                this.ui.finalScore.textContent = `YOUR SCORE: ${this.gameState.score}`;
                this.ui.gameOverScreen.classList.remove('hidden');
            }

            spawnEnemy() {
                this.enemySpawnTimer--;
                if (this.enemySpawnTimer <= 0) {
                    const radius = Math.random() * 
                        (GAME_CONSTANTS.ENEMY.MAX_RADIUS - GAME_CONSTANTS.ENEMY.MIN_RADIUS) + 
                        GAME_CONSTANTS.ENEMY.MIN_RADIUS;
                    
                    let x, y;
                    if (Math.random() < 0.5) {
                        x = Math.random() < 0.5 ? -radius : this.canvas.width + radius;
                        y = Math.random() * this.canvas.height;
                    } else {
                        x = Math.random() * this.canvas.width;
                        y = Math.random() < 0.5 ? -radius : this.canvas.height + radius;
                    }
                    
                    const color = GAME_CONSTANTS.ENEMY.COLORS[
                        Math.floor(Math.random() * GAME_CONSTANTS.ENEMY.COLORS.length)
                    ];
                    const angle = Math.atan2(this.player.y - y, this.player.x - x);
                    const velocity = { x: Math.cos(angle), y: Math.sin(angle) };
                    
                    const type = Math.random() < GAME_CONSTANTS.ENEMY.WANDERER_SPAWN_CHANCE ? 
                        'wanderer' : 'seeker';
                    
                    if (type === 'wanderer') {
                        velocity.x *= GAME_CONSTANTS.ENEMY.WANDERER_SPEED_MULTIPLIER;
                        velocity.y *= GAME_CONSTANTS.ENEMY.WANDERER_SPEED_MULTIPLIER;
                    }
                    
                    this.entityManager.addEnemy(new Enemy(x, y, radius, color, velocity, type));
                    
                    this.enemySpawnTimer = Math.max(
                        GAME_CONSTANTS.GAME.MIN_SPAWN_TIMER, 
                        GAME_CONSTANTS.GAME.INITIAL_SPAWN_TIMER - 
                        this.gameState.score / GAME_CONSTANTS.GAME.SPAWN_TIMER_SCORE_DIVISOR
                    );
                }
            }

            drawGrid() {
                this.ctx.save();
                this.ctx.strokeStyle = "rgba(0, 255, 255, 0.1)"; 
                this.ctx.lineWidth = 1;
                const gridSize = GAME_CONSTANTS.GAME.GRID_SIZE;
                
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath(); 
                    this.ctx.moveTo(x, 0); 
                    this.ctx.lineTo(x, this.canvas.height); 
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath(); 
                    this.ctx.moveTo(0, y); 
                    this.ctx.lineTo(this.canvas.width, y); 
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }

            update() {
                if (this.gameState.state === 'PLAYING') {
                    // プレイヤー更新
                    this.player.update(this.inputManager, this.canvas);
                    const projectile = this.player.tryShoot(this.inputManager);
                    this.entityManager.addProjectile(projectile);

                    // 敵スポーン
                    this.spawnEnemy();

                    // エンティティ更新
                    this.entityManager.update(this.player, this.canvas);

                    // 衝突判定
                    const collisions = this.entityManager.checkCollisions(this.player, this.gameState);
                    
                    if (collisions.playerHit) {
                        this.handlePlayerDeath();
                    }

                    collisions.enemiesKilled.forEach(({ enemy, projectile }) => {
                        this.entityManager.createExplosion(
                            projectile.x, projectile.y, enemy.color,
                            {
                                count: enemy.radius * GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_MULTIPLIER,
                                speed: GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_SPEED,
                                sizeMin: GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_SIZE_MIN,
                                sizeRange: GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_SIZE_RANGE,
                                life: GAME_CONSTANTS.PARTICLE.ENEMY_DEATH_LIFE
                            }
                        );
                        this.gameState.addScore(GAME_CONSTANTS.GAME.SCORE_PER_KILL);
                        this.updateUI();
                    });
                }
            }

            draw() {
                this.ctx.save();
                
                // 画面シェイク
                const shake = this.gameState.updateScreenShake();
                this.ctx.translate(shake.x, shake.y);

                // 背景
                this.ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawGrid();

                // ゲーム描画
                if (this.gameState.state === 'PLAYING') {
                    this.player.draw(this.ctx);
                    this.entityManager.draw(this.ctx);
                }

                this.ctx.restore();
            }

            gameLoop() {
                this.animationFrameId = requestAnimationFrame(() => this.gameLoop());

                // 開始入力チェック
                if (this.gameState.state !== 'PLAYING' && this.inputManager.isStartPressed()) {
                    this.start();
                }

                this.update();
                this.draw();
            }

            destroy() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
            }
        }

        // ゲーム初期化
        const game = new Game(document.getElementById('gameCanvas'));
        game.init();
    </script>
</body>
</html>